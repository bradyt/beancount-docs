<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Ledgerhub Design Doc - Beancount Documentation</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">Beancount Documentation</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="..">Index</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Outline <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">Documentation for Users</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../01_command_line_accounting_in_context/">Command Line Accounting in Context</a>
</li>
            
<li >
    <a href="../02_the_double_entry_counting_method/">The Double Entry Counting Method</a>
</li>
            
<li >
    <a href="../03_installing_beancount/">Installing Beancount</a>
</li>
            
<li >
    <a href="../04_running_beancount_and_generating_reports/">Running Beancount and Generating Reports</a>
</li>
            
<li >
    <a href="../05_getting_started_with_beancount/">Getting Started with Beancount</a>
</li>
            
<li >
    <a href="../06_beancount_language_syntax/">Beancount Language Syntax</a>
</li>
            
<li >
    <a href="../07_beancount_options_reference/">Beancount Options Reference</a>
</li>
            
<li >
    <a href="../08_precision_tolerances/">Precision Tolerances</a>
</li>
            
<li >
    <a href="../09_beancount_query_language/">Beancount Query Language</a>
</li>
            
<li >
    <a href="../10_beancount_cheat_sheet/">Beancount Cheat Sheet</a>
</li>
            
<li >
    <a href="../11_how_inventories_work/">How Inventories Work</a>
</li>
            
<li >
    <a href="../12_exporting_your_portfolio/">Exporting Your Portfolio</a>
</li>
            
<li >
    <a href="../13_tutorial_example/">Tutorial & Example</a>
</li>
            
<li >
    <a href="../14_beancount_history_and_credits/">Beancount History and Credits</a>
</li>
            
<li >
    <a href="../15_a_comparison_of_beancount_and_ledger_hledger/">A Comparison of Beancount and Ledger Hledger</a>
</li>
            
<li >
    <a href="../16_fetching_prices_in_beancount/">Fetching Prices in Beancount</a>
</li>
            
<li >
    <a href="../17_importing_external_data/">Importing External Data</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Cookbooks & Examples</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../18_command_line_accounting_cookbook/">Command Line Accounting Cookbook</a>
</li>
            
<li >
    <a href="../19_trading_with_beancount/">Trading with Beancount</a>
</li>
            
<li >
    <a href="../20_stock_vesting_in_beancount/">Stock Vesting in Beancount</a>
</li>
            
<li >
    <a href="../21_sharing_expenses_with_beancount/">Sharing Expenses with Beancount</a>
</li>
            
<li >
    <a href="../22_how_we_share_expenses/">How We Share Expenses</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Documentation for Developers</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../23_beancount_scripting_plugins/">Beancount Scripting Plugins</a>
</li>
            
<li >
    <a href="../24_beancount_design_doc/">Beancount Design Doc</a>
</li>
            
<li class="active">
    <a href="./">Ledgerhub Design Doc</a>
</li>
            
<li >
    <a href="../26_external_contributions/">External Contributions</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Enhancement Proposals & Discussions</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../27_a_proposal_for_an_improvement_on_inventory_booking/">A Proposal for an Improvement on Inventory Booking</a>
</li>
            
<li >
    <a href="../28_settlement_dates_in_beancount/">Settlement Dates in Beancount</a>
</li>
            
<li >
    <a href="../29_balance_assertions_in_beancount/">Balance Assertions in Beancount</a>
</li>
            
<li >
    <a href="../30_fund_accounting_with_beancount/">Fund Accounting with Beancount</a>
</li>
            
<li >
    <a href="../31_rounding_precision_in_beancount/">Rounding Precision in Beancount</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../24_beancount_design_doc/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../26_external_contributions/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/bradyt/beancount-docs/edit/master/docs/25_ledgerhub_design_doc.md"><i class="fa fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#design-doc-for-ledgerhub">Design Doc for Ledgerhub</a></li>
            <li><a href="#motivation">Motivation</a></li>
            <li><a href="#goals-stages">Goals &amp; Stages</a></li>
            <li><a href="#details-of-stages">Details of Stages</a></li>
            <li><a href="#implementation-details">Implementation Details</a></li>
            <li><a href="#importers-interface">Importers Interface</a></li>
            <li><a href="#references">References</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="design-doc-for-ledgerhub">Design Doc for Ledgerhub<a class="headerlink" href="#design-doc-for-ledgerhub" title="Permanent link">ÔÉÅ</a></h1>
<p><a href="mailto:blais@furius.ca"><span class="underline">Martin Blais</span></a>,
February 2014</p>
<p><a href="http://furius.ca/beancount/doc/ledgerhub-design-doc"><span
class="underline">http://furius.ca/beancount/doc/ledgerhub-design-doc</span></a></p>
<blockquote>
<p><a href="#motivation"><span class="underline">Motivation</span></a></p>
<p><a href="#goals-stages"><span class="underline">Goals &amp; Stages</span></a></p>
<p><a href="#details-of-stages"><span class="underline">Details of Stages</span></a></p>
<p><a href="#fetching"><span class="underline">Fetching</span></a></p>
<p><a href="#identification"><span class="underline">Identification</span></a></p>
<p><a href="#extraction"><span class="underline">Extraction</span></a></p>
<p><a href="#transform"><span class="underline">Transform</span></a></p>
<p><a href="#rendering"><span class="underline">Rendering</span></a></p>
<p><a href="#filing"><span class="underline">Filing</span></a></p>
<p><a href="#implementation-details"><span class="underline">Implementation
Details</span></a></p>
<p><a href="#importers-interface"><span class="underline">Importers
Interface</span></a></p>
<p><a href="#references"><span class="underline">References</span></a></p>
</blockquote>
<p><strong><em>Please note that this document is the original design doc for
LedgerHub. LedgerHub is being transitioned back to Beancount. See <a href="https://docs.google.com/document/d/1Bln8Zo11Cvez2rdEgpnM-oBHC1B6uPC18Qm7ulobolM/"><span
class="underline">this postmortem
document</span></a>
for details [blais, 2015-12].</em></strong></p>
<h2 id="motivation">Motivation<a class="headerlink" href="#motivation" title="Permanent link">ÔÉÅ</a></h2>
<p>Several open source projects currently exist that provide the capability
to create double-entry transactions for bookkeeping from a text file
input. These various double-entry bookkeeping projects include <a href="http://furius.ca/beancount/"><span
class="underline">Beancount</span></a>, <a href="http://ledger-cli.org/"><span
class="underline">Ledger</span></a>, <a href="http://hledger.org/"><span
class="underline">HLedger</span></a>, <a href="https://github.com/hrj/abandon"><span
class="underline">Abandon</span></a>, and
they are independent implementations of a similar goal: the creation of
an in-memory representation for double-entry accounting transactions
from a text file, and the production of various reports from it, such as
balance sheets, income statements, journals, and others. Each
implementation explores slightly different feature sets, but essentially
all work by reading their input from a file whose format is custom
declarative language that describe the transactions, a language which is
meant to be written by humans and whose syntax is designed with that
goal in mind. While the languages do vary somewhat, the underlying data
structures that they define are fairly similar.</p>
<p>An essential part of the process of regularly updating one‚Äôs journal
files is the replication of a real-world account‚Äôs transaction detail to
a single input file in a consistent data format. This is essentially a
translation step, meant to bring the transaction details of many
institutions‚Äô accounts into a single system. Various banks and credit
card companies provide downloadable transaction data in either Quicken
or Microsoft Money (OFX) formats, and many institutions provide custom
CSV files with transaction detail. Moreover, many of these institutions
also make regular statements available for download as PDF files, and
these can be associated with one‚Äôs ledger accounts.</p>
<p>The process of translating these external data formats can be automated
to some extent. These various files can be translated to output text
that can then be massaged by the user to be integrated into input file
formats accepted by a double-entry bookkeeping package. Several projects
have begun to make inroads in that domain: <a href="https://pypi.python.org/pypi/ledger-autosync/"><span
class="underline">Ledger-autosync</span></a>
aims at fetching transactions automatically from OFX servers for and
translating them for Ledger and HLedger, and <a href="https://github.com/cantino/reckon"><span
class="underline">Reckon</span></a>
converts CSV files for Ledger. <a href="http://furius.ca/beancount/"><span
class="underline">Beancount</span></a>
includes code that can automate the identification of downloaded files
to the accounts from a ledger, extract their transaction detail, and
automatically file them to a directory hierarchy that mirrors the
ledger‚Äôs chart of accounts. This code should probably live outside of
Beancount. <a href="http://ledger-cli.org/"><span
class="underline">Ledger</span></a> also sports a
‚Äúconvert‚Äù command that attempts to do similar things and a <a href="https://github.com/jwiegley/CSV2Ledger"><span
class="underline">CSV2Ledger</span></a>
Perl script is available that can convert CSV files. HLedger also had a
convert command which translated CSV files with optional conversion
hints defined in a separate file; HLedger now <a href="http://hledger.org/manual#csv-files"><span
class="underline">does the same conversion on-the-fly when the input
file is CSV</span></a> (i.e., CSV is
considered a first-class input format).</p>
<p>The programs that fetch and convert external data files do not have to
be tied to a single system. Moreover, this is often cumbersome code that
would benefit greatly from having a large number of contributors, which
could each benefit each other from having common parsers ready and
working for the various institutions that they‚Äôre using or likely to use
in the future. I - the author of Beancount - have decided to move
Beancount‚Äôs importing and filing source code outside of its home project
and to decouple it from the Beancount source code, so that others can
contribute to it, with the intent of providing project-agnostic
functionality. This document describes the goals and design of this
project.</p>
<h2 id="goals-stages">Goals &amp; Stages<a class="headerlink" href="#goals-stages" title="Permanent link">ÔÉÅ</a></h2>
<p>This new project should address the following aspects in a
project-agnostic manner:</p>
<ul>
<li>
<p><strong>Fetching</strong>: Automate <em>obtaining</em> the external data files by
    connecting to the data sources directly. External tools and
    libraries such as <a href="https://github.com/captin411/ofxclient"><span
    class="underline">ofxclient</span></a>
    for OFX sources can be leveraged for this purpose. Web scraping
    could be used to fetch downloadable files where possible. The output
    of this stage is a list of institution-specific files downloaded to
    a directory.<br />
    Note that fetching does not just apply to transaction data here; we
    will also support fetching <em>prices</em>. A list of (date, price) entries
    may be created from this data. We will likely want to support an
    intermediate format for expressing a list of positions (and
    appropriate support in the ledgerhub-Ledger/Beancount/HLedger
    interface to obtain it).</p>
</li>
<li>
<p><strong>Identification</strong>: Given a filename and its contents, automatically
    <em>guess</em> which institution and account configuration the file is for,
    and ideally be able to extract the date from the file or statement.
    This should also work with PDF files. The output of this stage is an
    association of each input file to a particular extractor and
    configuration (e.g. a particular account name).</p>
</li>
<li>
<p><strong>Extraction</strong>: <em>Parse each file</em> (if possible) and extract a list
    of information required to generate double-entry transactions data
    structures from it, in some sort of <em>generic</em> data structure, such
    as dicts of strings and numbers, independent of the underlying
    project‚Äôs desired output. If possible, a verbatim snippet of the
    original text that generated the transaction should be attached to
    the output data structure. The output of this stage is a data
    structure, e.g., a list of Python dictionaries in some defined
    format.</p>
</li>
<li>
<p><strong>Transform</strong>: Given some information from the past transaction
    history contained in a journal, using simple learning algorithms, a
    program should be able to apply transformations on the transactional
    information extracted from the previous step. The most common use
    case for this is to automatically add a categorization posting to
    transactions that have a single posting only. For example,
    transactions from credit card statements typically include the
    changes in balance of the credit card account but all transactions
    are left to be manually associated with a particular expense
    account. Some of this process can be automated at this stage.</p>
</li>
</ul>
<!-- -->

<ul>
<li>
<p><strong>Rendering</strong>: Convert the internal transactions data structures to
    the particular syntax of a double-entry bookkeeping project
    implementation and to the particular desired syntax variants (e.g.
    currency formatting, comma vs. dot decimal separator, localized
    input date format). This steps spits out text to be inserted into an
    input file compatible with the ledger software of choice.</p>
</li>
<li>
<p><strong>Filing</strong>: Sanitize the downloaded files‚Äô filenames and move them
    into a well organized and structured directory hierarchy
    corresponding to the identified account. This can run from the same
    associations derived in the identification step.</p>
</li>
</ul>
<p>Apart from the Render stage, all the other stages should be implemented
without regard for a particular project, this should work across all
ledger implementations. The Rendering code, however, should specialize,
import source code, and attempt to add as many of the particular
features provided by each project to its output text.</p>
<p>Where necessary, interfaces to obtain particular data sets from each
ledger implementation‚Äôs input files should be provided to shield the
common code from the particular implementation details of that project.
For instance, a categorization Transform step would need to train its
algorithm on some of the transaction data (i.e., the narration fields
and perhaps some of the amounts, account names, and dates). Each project
should provide a way to obtain the necessary data from its input data
file, in the same format.</p>
<h2 id="details-of-stages">Details of Stages<a class="headerlink" href="#details-of-stages" title="Permanent link">ÔÉÅ</a></h2>
<h3 id="fetching">Fetching<a class="headerlink" href="#fetching" title="Permanent link">ÔÉÅ</a></h3>
<p>By default, a user should be able to click their way to their
institution‚Äôs website and download documents to their ~/Downloads
directory. A directory with some files in it should be the reasonable
default input to the identification stage. This directory should be
allowed to have other/garbage files in it, the identification step
should be able to skip those automatically.</p>
<p>A module that can automatically fetch the data needs to be implemented.
Ideally this would not require an external tool. The data extracted
should also have a copy saved in some Downloads directory.</p>
<p>This is the domain of the ledger-autosync project. Perhaps we should
coordinate input/outputs or even integrate call some of its library code
at this stage. The author notes that fetching data from OFX servers is
pretty easy, though the begin/end dates will have to get processed and
filtered.</p>
<p>Automatic fetching support will vary widely depending on where the
institutions are located. Some places have solid support, some less. Use
the data from <a href="http://ofxhome.com"><span
class="underline">ofxhome.com</span></a> to configure.</p>
<h4 id="fetching-prices">Fetching Prices<a class="headerlink" href="#fetching-prices" title="Permanent link">ÔÉÅ</a></h4>
<p>For fetching prices, there are many libraries out there. Initially we
will port Beancount‚Äôs bean-prices to ledgerhub.</p>
<h3 id="identification">Identification<a class="headerlink" href="#identification" title="Permanent link">ÔÉÅ</a></h3>
<p>The identification stage consists in running a driver program that</p>
<ul>
<li>
<p>Searches for files in a directory hierarchy (typically your
    ~/Downloads folder)</p>
</li>
<li>
<p>If necessary, converts the files into some text/ascii format, so
    that regular expressions can be matched against it (even if the
    output is messy, e.g., with PDF files converted to ASCII). This
    works well for PDF files: despite the fact that we cannot typically
    extract transactional data from them, we can generally pretty
    reliably identify which account they‚Äôre for and almost always
    extract the statement date as well.</p>
</li>
<li>
<p>Check a list of regular expressions against the ASCII‚Äôfied contents.
    If the regular expressions all match, the configuration is
    associated to the filename.</p>
</li>
</ul>
<p>Note that more than one configuration may be associated to the same file
because some files contain many sections, sections for which different
importers may be called on to extract their data (e.g., OFX banking +
OFX credit card can be mixed in the same file, and some institutions
do).</p>
<p>The net result of this process is an association of each filename with
the a specific importer object instantiated in the configuration file.
These importer objects are created with a set of required account names
which they use to produce the Ledger-like syntax from the downloaded
file that was associated with it. Here is an example configuration for
two importers:</p>
<p>from ledgerhub.sources.rbc import rbcinvesting, rbcpdf</p>
<p>CONFIG = [</p>
<p>...</p>
<p>(('FileType: application/vnd.ms-excel', r'Filename:
.*Activity-123456789-', ),<br />
rbcinvesting.Importer({<br />
'FILE' : 'Assets:CA:RBC-Investing:Taxable',<br />
'cash' : 'Assets:CA:RBC-Investing:Taxable:Cash',<br />
'positions' : 'Assets:CA:RBC-Investing:Taxable',<br />
'interest' : 'Income:CA:RBC-Investing:Taxable:Interest',<br />
'dividend' : 'Income:CA:RBC-Investing:Taxable:Dividends',<br />
'fees' : 'Expenses:Financial:Fees',<br />
'commission' : 'Expenses:Financial:Commissions',<br />
'transfer' : 'Assets:CA:RBC:Checking',<br />
})),  </p>
<p>(('FileType: application/pdf',<br />
'Filename:.*/123456789-\d\d\d\d[A-Z][a-z][a-z]\d\d-\d\d\d\d[A-Z][a-z][a-z]\d\d.pdf'),<br />
rbcpdf.Importer({<br />
'FILE': 'Assets:CA:RBC-Investing:RRSP',<br />
})),</p>
<p>The configuration consists in a list, for each possible importer, of a
pair of 1) a list of regular expressions which all should match against
a ‚Äúmatch text‚Äù, which is a ‚Äútextified‚Äù version of the contents of a file
to be imported, and 2) an importer object, configured with a specific
set of accounts to use for producing transactions. Each importer
requires a particular set of output accounts which it uses to create its
transactions and postings. The ledger‚Äôs filename, and a list of these
(regexps, importer) pairs is all that is necessary for the driver to
carry out all of its work.</p>
<p>The textification consists in a simple and imperfect conversion of
downloaded file that are in binary format to something that we can run
regular expressions against. For an OFX file or CSV file there is no
conversion required for textification, we can just match against the
text contents of those files; for an Excel/XLS file, we need to convert
that to a CSV file, which can then be searched; for a PDF file, a number
of different pdf-to-text converters are attempted until one succeeds
(the tools for this are notoriously unreliable, so we have to try
various ones). Note that this converted "match text" is only created
temporarily and only for the purpose of identification; the importer
will get the original binary file to do its work.</p>
<p>It is not entirely clear whether the regular expressions can be
standardized to avoid having the user configure them manually. In
practice, I have found it often necessary, or at least very convenient,
to place an account id in my import configuration. It is true that
configuring each of the possible downloads can be a hassle that requires
the user to do a bit of guesswork while looking at the contents of each
file, but this has been much more reliable in practice than attempts at
normalizing this process, likely because it is a much easier problem to
uniquely distinguish between all the files of a particular user than to
distinguish between all the types of files. Using an account id in one
of the regular expressions is the easy way to do that, and it works
well. This also provides a clear place to attach the list of accounts to
a particular importer, something that necessarily requires user input
anyway.</p>
<h3 id="extraction">Extraction<a class="headerlink" href="#extraction" title="Permanent link">ÔÉÅ</a></h3>
<p>Once the association is made, we run the importers on each of the files.
Some data structure is produced. The importers each do what they do -
this is where the ugly tricks go. Ideally, we should build a library of
common utilities to help parsing similar file types.</p>
<p>Though each of the importer modules should be pretty much independent,
some common functionality can be imagined, for example, how one deals
with different stocks held in a single investment account, could be
configured outside of each importer (e.g., preferred method could be to
create a subaccount of that account, with the symbol of the stock, or
otherwise).</p>
<p>Note [AMaffei]: This could output a generic and well-defined CSV file
format if you want to have the option of running the various steps as
separate UNIX-style tools and/or process the intermediate files with
regular text processing tools.</p>
<h3 id="transform">Transform<a class="headerlink" href="#transform" title="Permanent link">ÔÉÅ</a></h3>
<p>Some transformations should be independent of importers. In particular,
automatically categorizing incomplete transactions is not dependent on
which importer created the transaction. I‚Äôd like to keep this step as
general as possible so that other embellishment steps can be inserted
here in the future. Right now, I can only think of the following uses:</p>
<ol>
<li>
<p>Auto-categorization of transactions with only a single leg</p>
</li>
<li>
<p>Detection of duplicate transactions: imported files often contain
    transactions which are already in the ledger; those should be either
    ignored or marked as such. In practice, this is not as easy as it
    sounds, because a straightforward date + narration comparison will
    fail: if the same transaction comes from two input data files, one
    side always ends up getting merged to the other, and sometimes even
    the date differs a bit. Some amount of fuzzy matching is required.</p>
</li>
<li>
<p>Normalization of payee names: the imported names of payees are often
    cut short or include some irrelevant words, such as ‚ÄúLLC‚Äù, city
    names, and/or number codes. It may be desirable to somehow clean
    those up automatically.</p>
</li>
</ol>
<p>This step involves a bootstrapping phase, where we will extract some
data from the actual ledger that the transactions are meant to be
imported into. We will implement a generic interface that should allow
each ledger language implementation to provide relevant data for
training.</p>
<p>The output data here should be in the same format as its input, so that
we can optionally skip this phase.</p>
<h3 id="rendering">Rendering<a class="headerlink" href="#rendering" title="Permanent link">ÔÉÅ</a></h3>
<p>An output renderer should be selected by the driver. This is where we
convert the extracted data structures to the particular flavor of ledger
implementation you‚Äôre using. Each of the renderer implementations should
be free to import modules from its particular implementation, and we
should be careful to constraint these import dependencies to only these
modules, to make sure that only a single ledger implementation is
required in order for the code to run.</p>
<p>Options for rendering style could be defined here, for each renderer,
because each of the languages have particularies.</p>
<p>[AMaffei] Also, it should be possible to provide a generic renderer
that takes printf-style format strings to output in any desired format.</p>
<h3 id="filing">Filing<a class="headerlink" href="#filing" title="Permanent link">ÔÉÅ</a></h3>
<p>Importers should be able to look at the textified contents of the files
and find the file/statement date. This is useful, because we can rename
the file by prepending the date of the statement, and the date at which
we download the statement or transaction files is rarely the same date
at which it was generated. In the case where we are not able to extract
a date from the file, we fall back on the filename‚Äôs last modified time.</p>
<p>A target directory should be provided and we should move each file to
the account with which it is associated. For example, a file like this:</p>
<pre><code>~/Downloads/ofx32755.qbo
</code></pre>
<p>should be moved to a directory</p>
<pre><code>.../Assets/US/RBC/Checking/2013-11-27.ofx32755.qbo
</code></pre>
<p>if it is associated by the identification step with an importer for the
Assets:US:RBC:Checking account. For this purpose, all the importers
should have a required ‚Äúfiling‚Äù account associated with them.</p>
<p>As far as I know only Beancount implements this at the moment, but I
suspect this convenient mechanism of organizing and preserving your
imported files will be found useful by others. Given a list of
directories, Beancount automatically finds those files and using the
date in the filename, is able to render links to the files as line items
in the journal web pages, and serve their contents when the user clicks
on the links. Even without this capability, it can be used to maintain a
cache of your documents (I maintain mine in a repository which I sync to
an external drive for backup).</p>
<h2 id="implementation-details">Implementation Details<a class="headerlink" href="#implementation-details" title="Permanent link">ÔÉÅ</a></h2>
<p>Notes about the initial implementation:</p>
<ul>
<li>
<p>The implementation of this project will be carried out in Python3.
    Why Python?</p>
<ul>
<li>
<p>The performance of importing and extracting is largely
    irrelevant, a dynamic language works well for this type of task</p>
</li>
<li>
<p>Parsing in a dynamic language works great, there are many
    available libraries</p>
</li>
<li>
<p>Python3 is now widely distributed and all desired parsing
    libraries are commonly available for it at this point</p>
</li>
</ul>
</li>
<li>
<p>The project will be hosted at either <a href="http://hg.furius.ca/public/ledgerhub/"><span
    class="underline">http://hg.furius.ca/public/ledgerhub/</span></a>
    (or perhaps <a href="https://bitbucket.org/blais/ledgerhub/"><span
    class="underline">https://bitbucket.org/blais/ledgerhub/</span></a>
    ?)</p>
</li>
<li>
<p>All modules should be tested, including testing with sample input.
    If you want to add a new module, you should need to provide an
    anonymized sample file for it. We will have to have an automated
    test suite, because past experience has shown this type of code to
    be quite brittle and fragile to new and unexpected inputs. It‚Äôs easy
    to write, but it‚Äôs also easy to break.</p>
<ul>
<li>In order to test binary files that cannot be anonymized, we will
    provide the ability to test from match-text instead of from
    original binary statement PDF. Those files are generally not
    extractable anyhow and are only there for identification and
    filing (e.g. a PDF statement, we can‚Äôt extract any meaningful
    data out of those except perhaps for the statement date).</li>
</ul>
</li>
<li>
<p>There should be a quick way to test a particular importer with a
    particular downloaded file with zero configuration, even if the
    output account names are a little wonky.</p>
</li>
<li>
<p>There needs to be clean and readable tracing for what the importers
    are doing, including a debugging/verbose option.</p>
</li>
<li>
<p>We provide a single function to call as the driver for your own
    import script. Your configuration is a script / your script is the
    configuration. You call a function at the end. We will also provide
    a script that imports a filename and fetches an attribute from it,
    for those who want a more traditional invocation.</p>
</li>
<li>
<p>We should keep types simples, but use the standard datetime types
    for dates, decimal.Decimal for numbers, and strings for
    currencies/commodities.</p>
</li>
</ul>
<p>This is obviously based on my current importers code in Beancount. I‚Äôm
very open to new ideas and suggestions for this project. Collaborations
will be most welcome. The more importers we can support, the better.</p>
<h2 id="importers-interface">Importers Interface<a class="headerlink" href="#importers-interface" title="Permanent link">ÔÉÅ</a></h2>
<p>Each importer should be implemented as a class that derives from this
one:</p>
<p>class ImporterBase:<br />
"Base class/interface for all source importers."  </p>
<p># A dict of required configuration variables to their docstring.<br />
# This declares the list of options required for the importer<br />
# to be provided with, and their meaning.<br />
<strong>REQUIRED_CONFIG</strong> = {}  </p>
<p>def __init__(self, config):<br />
"""Create an importer.<br />
Most concrete implementations can just use this without overriding.  </p>
<p>Args:<br />
config: A dict of configuration accounts, that must match the<br />
REQUIRED_CONFIG values.<br />
"""<br />
# a dict of Configuration values. This can be accessed publicly.<br />
assert isinstance(config, dict)<br />
self.config = config  </p>
<p># Check that the config has just the required configuration values.<br />
if not verify_config(self, config, self.REQUIRED_CONFIG):<br />
raise ValueError("Invalid config {}, requires {}".format(<br />
config, self.REQUIRED_CONFIG))  </p>
<p>def get_filing_account(self):<br />
"""Return the account for moving the input file to.  </p>
<p>Returns:<br />
The name of the account that corresponds to this importer.<br />
"""<br />
return self.config['FILE']  </p>
<p>def <strong>import_file</strong>(self, filename):<br />
"""Attempt to import a file.  </p>
<p>Args:<br />
filename: the name of the file to be imported.<br />
Returns:<br />
A list of new, imported entries extracted from the file.<br />
"""<br />
raise NotImplementedError  </p>
<p>def <strong>import_date</strong>(self, filename, text_contents):<br />
"""Attempt to obtain a date that corresponds to the given file.  </p>
<p>Args:<br />
filename: the name of the file to extract the date from<br />
text_contents: an ASCII text version of the file contents,<br />
whatever format it is originally in.<br />
Returns:<br />
A date object, if successful, or None.<br />
"""<br />
raise NotImplementedError</p>
<p>For each importer, a detailed explanation of how the original input file
on the institution‚Äôs website is to be found and downloaded should be
provided, to help those find the correct download when adding this
importer (some institutions provide a variety of download formats). In
addition, a one-line description of the input file support should be
provided, so that we can render at runtime a list of the supported file
types.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">ÔÉÅ</a></h2>
<p>Other projects with the same goal as importing account data into Ledger
are listed here.</p>
<ul>
<li>
<p><a href="http://ledger-cli.org/3.0/doc/ledger3.html#The-convert-command"><span class="underline">Ledger‚Äôs ‚Äúconvert‚Äù
    command</span></a></p>
</li>
<li>
<p>HLedger with its <a href="http://hledger.org/manual#csv-files"><span
    class="underline">built-in</span></a>
    <a href="http://hledger.org/manual#timelog-files"><span
    class="underline">readers</span></a></p>
</li>
<li>
<p><span class="underline">Reckon</span></p>
</li>
<li>
<p><a href="https://github.com/captin411/ofxmate"><span
    class="underline">OFXmate</span></a>
    (GUI for ledger-autosync)</p>
</li>
<li>
<p><a href="https://github.com/jwiegley/CSV2Ledger"><span
    class="underline">CSV2Ledger</span></a></p>
</li>
<li>
<p><a href="https://github.com/quentinsf/icsv2ledger"><span
    class="underline">icsv2ledger</span></a></p>
</li>
<li>
<p><a href="http://www.khjk.org/log/2009/oct/csv2ledger.hs"><span
    class="underline">csv2ledger</span></a>
    (seems to lack active maintainers)</p>
</li>
</ul>
<p>Update (Nov 2015): This design doc has been implemented and the project
is being transitioned back to Beancount. Read the details <a href="https://docs.google.com/document/d/1Bln8Zo11Cvez2rdEgpnM-oBHC1B6uPC18Qm7ulobolM/"><span
class="underline">here</span></a>.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
